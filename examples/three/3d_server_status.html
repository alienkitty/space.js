<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Server Status â€” Space.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1:wght@500;700">
    <link rel="stylesheet" href="../assets/css/style.css">

    <style>
        *, :after, :before {
            touch-action: unset;
        }

        body {
            position: unset;
            -moz-osx-font-smoothing: auto;
            -webkit-font-smoothing: auto;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three/build/three.module.js",
                "three/addons/": "https://unpkg.com/three/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import { BoxGeometry, Color, Group, HemisphereLight, MathUtils, Mesh, MeshNormalMaterial, PerspectiveCamera, Scene, WebGLRenderer } from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        import { EventEmitter, Interface, PanelItem, Point3D, RadialGraphContainer, RadialGraphSegmentsCanvas, Stage, UI, average, consecutive, delayedCall, lerpCameras, median, peaks, ticker, tween } from '../../src/three.js';

        const isDebug = /[?&]debug/.test(location.search);

        class Utils {
            // https://stackoverflow.com/questions/36098913/convert-seconds-to-days-hours-minutes-and-seconds/52387803#52387803
            static formatSeconds(seconds) {
                seconds = Number(seconds);

                const d = Math.floor(seconds / 86400);
                const h = Math.floor(seconds % 86400 / 3600);
                const m = Math.floor(seconds % 3600 / 60);
                const s = Math.floor(seconds % 60);

                const daysFormatted = d > 0 ? `${d}${(d === 1 ? ' day ' : ' days ')}` : '';
                const hoursFormatted = h > 0 ? `${h}${(h === 1 ? ' hour ' : ' hours ')}` : '';
                const minutesFormatted = m > 0 ? `${m}${(m === 1 ? ' minute ' : ' minutes ')}` : '';
                const secondsFormatted = `${s}${(s === 1 ? ' second' : ' seconds')}`;

                return `${daysFormatted}${hoursFormatted}${minutesFormatted}${secondsFormatted}`;
            }

            static formatInfoSeconds(seconds) {
                seconds = Number(seconds);
                if (seconds < 60) return 'now';
                if (seconds < 3600) return `${Math.floor(seconds % 3600 / 60)}min`;
                if (seconds < 86400) return `${Math.floor(seconds % 86400 / 3600)}h`;
                return `${Math.floor(seconds / 86400)}d`;
            }

            static formatDateTimeSeconds(seconds) {
                seconds = Number(seconds);
                return new Date(seconds * 1000).toLocaleString('default', {
                    month: 'short',
                    day: 'numeric',
                    // year: 'numeric',
                    hour: 'numeric',
                    minute: 'numeric',
                    hour12: false
                });
            }

            // https://stackoverflow.com/questions/32054170/how-to-resize-an-array/32055229#32055229
            static backfill(array, size, value) {
                return [...Array(Math.max(0, size - array.length)).fill(value), ...array];
            }
        }

        class Data {
            static init({ projectDomain, networkName }) {
                this.projectDomain = projectDomain;
                this.networkName = networkName;
            }

            // Public methods

            static getName = () => {
                // return basename(this.projectDomain);
                return 'server-status';
            };

            static getType = () => {
                return this.networkName.match(/\(([^)]+)\)/).pop();
            };
        }

        class TimestampData {
            constructor() {
                this.array = [];
                this.markers = [];

                // Median downsample
                this.largeChunkSize = 120;
                this.smallChunkSize = 10;
                this.largeCounter = 0;
            }

            parse() {
                // Median downsample
                let array = [];
                const chunkSize = this.smallChunkSize;

                for (let i = 0, l = this.array.length; i < l; i += chunkSize) {
                    array.push(median(this.array.slice(i, i + chunkSize)));
                }

                // Duplicate first value for truncated array
                if (array.length < 1080) {
                    array = Utils.backfill(array, 1080, array[0] || 0);
                }

                // Past 12hrs (~10800 status updates) downsampled to 1080
                this.markersArray = [];
                this.labelsArray = [];
                let lastDate;
                const markers = Array.from(this.markers);

                for (let i = 0, l = array.length; i < l; i++) {
                    const value = array[i];
                    const formatted = Utils.formatDateTimeSeconds(value);
                    const [date, time] = formatted.split(/, | at /);

                    if (i === 0) {
                        lastDate = date;
                    }

                    if (date !== lastDate) {
                        this.markersArray.push([i / l, date]); // position, name
                        lastDate = date;
                    }

                    this.labelsArray.push(time);

                    // Additional markers
                    markers.forEach(data => {
                        const [seconds, name] = data;

                        if (value > seconds) {
                            const index = markers.indexOf(data);

                            if (~index) {
                                markers.splice(index, 1);
                            }

                            // Only add the marker if it's within the window size
                            if (i !== 0) {
                                this.markersArray.push([i / l, name]); // position, name
                            }
                        }
                    });
                }

                // Reversed
                this.markersArrayReversed = this.markersArray.toReversed().map(data => {
                    data[0] = 1 - data[0];
                    return data;
                });
                this.labelsArrayReversed = this.labelsArray.toReversed();

                // Cleanup
                array.length = 0;
            }

            // Public methods

            setData = data => {
                // Past 12hrs (~10800 status updates)
                this.array = data.slice(-10800);

                this.parse();
            };

            getArrays = () => ({
                array: this.array,
                markersArray: this.markersArray,
                markersArrayReversed: this.markersArrayReversed,
                labelsArray: this.labelsArray,
                labelsArrayReversed: this.labelsArrayReversed
            });

            setArrays = ({
                array,
                markersArray,
                markersArrayReversed,
                labelsArray,
                labelsArrayReversed
            }) => {
                this.array = array;
                this.markersArray = markersArray;
                this.markersArrayReversed = markersArrayReversed;
                this.labelsArray = labelsArray;
                this.labelsArrayReversed = labelsArrayReversed;
            };

            addMarker(data) {
                this.markers.push(data);

                this.parse();
            }

            update = value => {
                this.array.shift();
                this.array.push(value);

                if (++this.largeCounter === this.largeChunkSize) {
                    this.parse();

                    this.largeCounter = 0;
                }
            };
        }

        class GraphData {
            constructor() {
                this.array = [];

                // Graph averages
                this.largeGhostArray = [];
                this.largeArray = [];
                this.smallGhostArray = [];
                this.smallArray = [];

                // Median downsample
                this.largeChunkSize = 120;
                this.smallChunkSize = 10;
                this.largeCounter = 0;
                this.smallCounter = 0;
            }

            // Public methods

            setData = data => {
                // Past 12hrs (~10800 status updates)
                this.array = data.slice(-10800);

                // Last 240 status updates for small graph (120 + 120, ghost + array)
                const smallData = data.slice(-240);

                // Last 20 status updates for realtime graph (10 + 10, ghost + array)
                const realtimeData = data.slice(-20);
                this.realtimeGhostArray = realtimeData.slice(0, 10);
                this.realtimeArray = realtimeData.slice(-10);

                // Large median downsample
                const array = [];
                let chunkSize = this.largeChunkSize;

                for (let i = 0, l = data.length; i < l; i += chunkSize) {
                    array.push(median(data.slice(i, i + chunkSize)));
                }

                // Past day (~21600 status updates) downsampled to 180 (90 + 90, ghost + array)
                this.largeArray = array.splice(-90, 90);

                if (this.largeArray.length < 90) {
                    this.largeArray = Utils.backfill(this.largeArray, 90, this.largeArray[0] || 0);
                }

                this.largeGhostArray = array.splice(-90, 90);

                if (this.largeGhostArray.length < 90) {
                    this.largeGhostArray = Utils.backfill(this.largeGhostArray, 90, this.largeGhostArray[0] || 0);
                }

                // Small median downsample
                array.length = 0;
                chunkSize = this.smallChunkSize;

                for (let i = 0, l = smallData.length; i < l; i += chunkSize) {
                    array.push(median(smallData.slice(i, i + chunkSize)));
                }

                // Last 240 status updates downsampled to 24 (12 + 12, ghost + array)
                this.smallArray = array.splice(-12, 12);

                if (this.smallArray.length < 12) {
                    this.smallArray = Utils.backfill(this.smallArray, 12, this.smallArray[0] || 0);
                }

                this.smallGhostArray = array.splice(-12, 12);

                if (this.smallGhostArray.length < 12) {
                    this.smallGhostArray = Utils.backfill(this.smallGhostArray, 12, this.smallGhostArray[0] || 0);
                }

                // Reversed
                this.largeGhostArrayReversed = this.largeGhostArray.toReversed();
                this.largeArrayReversed = this.largeArray.toReversed();
                this.smallGhostArrayReversed = this.smallGhostArray.toReversed();
                this.smallArrayReversed = this.smallArray.toReversed();

                // Cleanup
                smallData.length = 0;
                realtimeData.length = 0;
                array.length = 0;
            };

            getArrays = () => ({
                array: this.array,
                largeGhostArray: this.largeGhostArray,
                largeGhostArrayReversed: this.largeGhostArrayReversed,
                largeArray: this.largeArray,
                largeArrayReversed: this.largeArrayReversed,
                smallGhostArray: this.smallGhostArray,
                smallGhostArrayReversed: this.smallGhostArrayReversed,
                smallArray: this.smallArray,
                smallArrayReversed: this.smallArrayReversed,
                realtimeGhostArray: this.realtimeGhostArray,
                realtimeArray: this.realtimeArray
            });

            setArrays = ({
                array,
                largeGhostArray,
                largeGhostArrayReversed,
                largeArray,
                largeArrayReversed,
                smallGhostArray,
                smallGhostArrayReversed,
                smallArray,
                smallArrayReversed,
                realtimeGhostArray,
                realtimeArray
            }) => {
                this.array = array;
                this.largeGhostArray = largeGhostArray;
                this.largeGhostArrayReversed = largeGhostArrayReversed;
                this.largeArray = largeArray;
                this.largeArrayReversed = largeArrayReversed;
                this.smallGhostArray = smallGhostArray;
                this.smallGhostArrayReversed = smallGhostArrayReversed;
                this.smallArray = smallArray;
                this.smallArrayReversed = smallArrayReversed;
                this.realtimeGhostArray = realtimeGhostArray;
                this.realtimeArray = realtimeArray;
            };

            getPeaks = threshold => {
                // Past 12hrs (~10800 status updates)
                const groups = consecutive(peaks(this.array, this.largeChunkSize / 2, threshold));

                return groups.map(array => array[0] / 10800); // First index normalized
            };

            update = value => {
                this.array.shift();
                this.array.push(value);

                // Last 20 status updates for realtime graph (10 + 10, ghost + array)
                const realtimeData = this.array.slice(-20);
                this.realtimeGhostArray = realtimeData.slice(0, 10);
                this.realtimeArray = realtimeData.slice(-10);

                // Small median downsample
                if (++this.smallCounter === this.smallChunkSize) {
                    const smallGhost = this.smallArray.shift();
                    this.smallArray.push(median(this.realtimeArray));
                    this.smallGhostArray.shift();
                    this.smallGhostArray.push(smallGhost);

                    // Small reversed
                    this.smallGhostArrayReversed = this.smallGhostArray.toReversed();
                    this.smallArrayReversed = this.smallArray.toReversed();

                    this.smallCounter = 0;
                }

                // Large median downsample
                if (++this.largeCounter === this.largeChunkSize) {
                    const largeGhost = this.largeArray.shift();
                    this.largeArray.push(median(this.array.slice(-this.largeChunkSize)));
                    this.largeGhostArray.shift();
                    this.largeGhostArray.push(largeGhost);

                    // Large reversed
                    this.largeGhostArrayReversed = this.largeGhostArray.toReversed();
                    this.largeArrayReversed = this.largeArray.toReversed();

                    this.largeCounter = 0;
                }

                // Cleanup
                realtimeData.length = 0;
            };
        }

        class Socket extends EventEmitter {
            constructor(server) {
                super();

                this.server = server;

                this.connected = false;

                // Latency average
                this.latencyArray = [];

                this.connect();
            }

            addListeners() {
                this.socket.addEventListener('open', this.onOpen);
                this.socket.addEventListener('close', this.onClose);
                this.socket.addEventListener('message', this.onMessage);
            }

            removeListeners() {
                this.socket.removeEventListener('open', this.onOpen);
                this.socket.removeEventListener('close', this.onClose);
                this.socket.removeEventListener('message', this.onMessage);
            }

            // Event handlers

            onOpen = () => {
                this.connected = true;

                const event = 'subscribe';
                const message = {
                    subscription: {
                        name: 'server-status',
                        time: 86400 // Past day in seconds
                    }
                };

                console.log('send', event, message);
                this.send({ event, message });
            };

            onClose = () => {
                console.log('close');
                this.connected = false;

                delayedCall(250, this.connect);
            };

            onMessage = ({ data }) => {
                const { event, message } = JSON.parse(data);
                console.log('message', event, message);

                switch (event) {
                    case 'heartbeat':
                        this.send({ event, message });
                        break;
                    case 'server-details': {
                        const { details/* , serverUptime, latency */ } = message;

                        const {
                            // packageVersion,
                            projectDomain,
                            networkName,
                            serverVersion,
                            restartTime,
                            memTotal,
                            memFree,
                            swapTotal,
                            swapFree,
                            storageTotal,
                            storageAvailable,
                            processorName,
                            numProcessingUnits
                        } = details;

                        const memUsed = memTotal - memFree;

                        let memUsedFormatted = memUsed / 1024 / 1024 / 1024;
                        memUsedFormatted = `${Math.round((memUsedFormatted + Number.EPSILON) * 100) / 100} GiB`;

                        let memTotalFormatted = memTotal / 1024 / 1024 / 1024;
                        memTotalFormatted = `${Math.round((memTotalFormatted + Number.EPSILON) * 100) / 100} GiB`;

                        let memUsedPercentage = (memUsed / memTotal) * 100;
                        memUsedPercentage = Math.round((memUsedPercentage + Number.EPSILON) * 100) / 100;

                        const swapUsed = swapTotal - swapFree;

                        let swapUsedFormatted = swapUsed / 1024 / 1024 / 1024;
                        swapUsedFormatted = `${Math.round((swapUsedFormatted + Number.EPSILON) * 100) / 100} GiB`;

                        let swapTotalFormatted = swapTotal / 1024 / 1024 / 1024;
                        swapTotalFormatted = `${Math.round((swapTotalFormatted + Number.EPSILON) * 100) / 100} GiB`;

                        let swapUsedPercentage = (swapUsed / swapTotal) * 100;
                        swapUsedPercentage = Math.round((swapUsedPercentage + Number.EPSILON) * 100) / 100;

                        const storageUsed = storageTotal - storageAvailable;

                        let storageUsedFormatted;
                        let storageTotalFormatted;

                        if (storageTotal < 1e9) {
                            storageUsedFormatted = storageUsed / 1000 / 1000;
                            storageUsedFormatted = `${Math.round((storageUsedFormatted + Number.EPSILON) * 100) / 100} MB`;

                            storageTotalFormatted = storageTotal / 1000 / 1000;
                            storageTotalFormatted = `${Math.round((storageTotalFormatted + Number.EPSILON) * 100) / 100} MB`;
                        } else {
                            storageUsedFormatted = storageUsed / 1000 / 1000 / 1000;
                            storageUsedFormatted = `${Math.round((storageUsedFormatted + Number.EPSILON) * 100) / 100} GB`;

                            storageTotalFormatted = storageTotal / 1000 / 1000 / 1000;
                            storageTotalFormatted = `${Math.round((storageTotalFormatted + Number.EPSILON) * 100) / 100} GB`;
                        }

                        let storageUsedPercentage = (storageUsed / storageTotal) * 100;
                        storageUsedPercentage = Math.round((storageUsedPercentage + Number.EPSILON) * 100) / 100;

                        this.emit('details', {
                            projectDomain,
                            networkName,
                            serverVersion,
                            restartTime,
                            memUsed: memUsedFormatted,
                            memTotal: memTotalFormatted,
                            memUsedPercentage,
                            swapUsed: swapUsedFormatted,
                            swapTotal: swapTotalFormatted,
                            swapUsedPercentage,
                            storageUsed: storageUsedFormatted,
                            storageTotal: storageTotalFormatted,
                            storageUsedPercentage,
                            processorName,
                            numProcessingUnits
                        });
                        break;
                    }
                    case 'server-status': {
                        const { status, serverUptime, latency } = message;

                        let data = status;

                        // Initial data dump
                        if (data.length > 3) {
                            // Separate last status update as new update
                            const last = data.pop();

                            // Timestamp data
                            this.timestampData = new TimestampData();
                            this.timestampData.setData(data.map(data => data[0])); // seconds

                            // Latency average data (initially no data, all 0s)
                            this.latencyAvgData = new GraphData();
                            this.latencyAvgData.setData(new Array(data.length).fill(0));

                            // Load average data
                            this.loadAvgData = new GraphData();
                            this.loadAvgData.setData(data.map(data => data[1] * 100)); // percentage

                            // Clients data
                            this.clientsData = new GraphData();
                            this.clientsData.setData(data.map(data => data[2]));

                            this.emit('data', {
                                timestampData: this.timestampData.getArrays(),
                                latencyAvgData: this.latencyAvgData.getArrays(),
                                loadAvgData: this.loadAvgData.getArrays(),
                                clientsData: this.clientsData.getArrays()
                            });

                            data = last;
                        }

                        if (latency !== undefined) {
                            this.latencyArray.push(latency);
                        }

                        const currentTime = data[0]; // seconds
                        const serverUptimeFormatted = Utils.formatSeconds(serverUptime);

                        let latencyAvg;

                        if (this.latencyArray.length) {
                            latencyAvg = Math.round(average(this.latencyArray));
                        }

                        let loadAvg = data[1] * 100; // percentage
                        loadAvg = Math.round(loadAvg);

                        const numClients = data[2];

                        // Update data
                        this.timestampData.update(currentTime);
                        this.latencyAvgData.update(latencyAvg);
                        this.loadAvgData.update(loadAvg);
                        this.clientsData.update(numClients);

                        this.emit('status', {
                            currentTime,
                            serverUptime,
                            serverUptimeFormatted,
                            latency,
                            latencyAvg,
                            loadAvg,
                            numClients
                        });
                        break;
                    }
                }
            };

            // Public methods

            getPeaks = (name, threshold) => {
                return this[name].getPeaks(threshold);
            };

            send = data => {
                if (!this.connected) {
                    return;
                }

                this.socket.send(JSON.stringify(data));
            };

            connect = () => {
                if (this.socket) {
                    this.close();
                }

                this.socket = new WebSocket(this.server, ['permessage-deflate']);

                this.addListeners();
            };

            close = () => {
                this.removeListeners();

                this.socket.close();
            };
        }

        class TrackersView extends Interface {
            constructor() {
                super('.trackers');

                this.init();
            }

            init() {
                this.css({
                    position: 'fixed',
                    left: 0,
                    top: 0,
                    width: '100%',
                    height: '100%',
                    pointerEvents: 'none',
                    webkitUserSelect: 'none',
                    userSelect: 'none'
                });
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const geometry = new BoxGeometry();
                geometry.computeTangents();

                const material = new MeshNormalMaterial();

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            update = time => {
                this.mesh.rotation.x = time / 2;
                this.mesh.rotation.y = time;
            };
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static update = time => {
                this.view.update(time);
            };
        }

        class ScenePanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();
            }

            static initPanel() {
                const view = this.view;

                const objects = [view];

                objects.forEach(object => {
                    // Note the `start` and `graphHeight` parameters are used for the point position
                    object.graph = new RadialGraphContainer({
                        start: -45,
                        graphHeight: 40
                    });

                    object.latencyAvgGraph = new RadialGraphSegmentsCanvas({
                        start: -45,
                        graphHeight: 40,
                        resolution: 102,
                        tension: 12,
                        lookupPrecision: [25, 200],
                        segments: [12, 90],
                        ratio: [0.125, 0.875], // 45 / 360 = 0.125
                        labels: ['', '12hrs'],
                        range: 300,
                        suffix: 'ms',
                        noMarkerDrag: true
                    });
                    object.graph.add(object.latencyAvgGraph);

                    object.loadAvgGraph = new RadialGraphSegmentsCanvas({
                        start: -45,
                        graphHeight: 40,
                        resolution: 102,
                        tension: 6,
                        lookupPrecision: [25, 200],
                        segments: [12, 90],
                        ratio: [0.125, 0.875], // 45 / 360 = 0.125
                        labels: ['', '12hrs'],
                        range: 400,
                        suffix: '%',
                        noMarkerDrag: true
                    });
                    object.graph.add(object.loadAvgGraph);

                    object.clientsGraph = new RadialGraphSegmentsCanvas({
                        start: -45,
                        graphHeight: 40,
                        resolution: 102,
                        tension: 12,
                        lookupPrecision: [25, 200],
                        segments: [12, 90],
                        ratio: [0.125, 0.875], // 45 / 360 = 0.125
                        labels: ['', '12hrs'],
                        range: 10,
                        noMarkerDrag: true
                    });
                    object.graph.add(object.clientsGraph);

                    // Default graph (load average)
                    object.graph.setIndex(1);

                    object.point = new Point3D(object.mesh, {
                        name: Data.getName(),
                        type: Data.getType(),
                        graph: object.graph
                    });
                    object.add(object.point);

                    const graphOptions = {
                        'Latency': 0,
                        'Load': 1,
                        'Clients': 2
                    };

                    const items = [
                        {
                            type: 'divider'
                        },
                        {
                            type: 'list',
                            name: 'Graph',
                            list: graphOptions,
                            value: 'Load',
                            callback: value => {
                                const index = graphOptions[value];
                                object.graph.setIndex(index);
                            }
                        },
                        {
                            type: 'divider'
                        },
                        {
                            type: 'link',
                            value: 'Details',
                            callback: () => {
                                this.ui.toggleDetails(!this.ui.details.animatedIn);
                                object.point.animateOut(true);
                                object.point.deactivate();
                            }
                        }
                    ];

                    items.forEach(data => {
                        object.point.addPanel(new PanelItem(data));
                    });
                });

                // Shrink tracker mesh to better match the visual size of the object
                view.point.mesh.scale.multiplyScalar(0.8);
            }
        }

        class PanelController {
            static init(renderer, scene, camera, view, trackers, ui) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;
                this.trackers = trackers;
                this.ui = ui;

                this.initControllers();
            }

            static initControllers() {
                Point3D.init(this.renderer, this.scene, this.camera, {
                    container: this.trackers,
                    dividerSnap: this.ui.details.dividerLine,
                    debug: isDebug
                });

                ScenePanelController.init(this.view, this.ui);
            }

            // Public methods

            static update = time => {
                if (!this.ui) {
                    return;
                }

                Point3D.update(time);
            };
        }

        class ServerStatusController {
            static init(view, trackers) {
                this.view = view;
                this.trackers = trackers;

                this.initSocket();

                this.addListeners();
            }

            static initSocket() {
                this.socket = new Socket('wss://hello-websockets-server-status.glitch.me');
            }

            static initPanel() {
                const { renderer, scene, camera } = WorldController;

                PanelController.init(renderer, scene, camera, this.view, this.trackers, this.ui);
            }

            static addListeners() {
                this.socket.on('details', this.onDetails);
                this.socket.on('data', this.onData);
                this.socket.on('status', this.onStatus);
            }

            // Event handlers

            static onDetails = ({
                projectDomain,
                networkName,
                serverVersion,
                restartTime,
                memUsed,
                memTotal,
                memUsedPercentage,
                swapUsed,
                swapTotal,
                swapUsedPercentage,
                storageUsed,
                storageTotal,
                storageUsedPercentage,
                processorName,
                numProcessingUnits
            }) => {
                this.restartTime = restartTime;

                if (!this.ui) {
                    this.ui = new UI({
                        fps: true,
                        details: {
                            dividerLine: true,
                            width: '50vw',
                            title: 'server-status'.replace(/[\s.-]+/g, '_'),
                            content: [
                                {
                                    content: 'A simple status API endpoint built on Express, like the Apache status page.',
                                    links: [
                                        {
                                            title: 'Source code',
                                            link: 'https://github.com/pschroen/hello-websockets-server-status'
                                        }
                                    ],
                                    width: '100%'
                                },
                                {
                                    group: [
                                        {
                                            title: 'Server version',
                                            content: serverVersion,
                                            width: 110
                                        },
                                        {
                                            title: 'Uptime',
                                            content: '',
                                            width: 200
                                        },
                                        {
                                            title: 'Latency',
                                            meter: {
                                                suffix: 'ms',
                                                range: 150,
                                                value: 0,
                                                width: 70,
                                                noRange: true
                                            }
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Network',
                                            content: `${projectDomain}<br>${networkName}`,
                                            width: 330
                                        },
                                        {
                                            title: 'Clients',
                                            content: '',
                                            width: 70
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Latency',
                                            content: '0ms (avg)',
                                            width: 200,
                                            meter: {
                                                range: 300,
                                                value: 0,
                                                width: 200,
                                                ghost: true,
                                                noText: true
                                            }
                                        },
                                        {
                                            title: '',
                                            graph: {
                                                suffix: 'ms',
                                                resolution: 160,
                                                range: 300,
                                                width: 200,
                                                height: 48,
                                                ghost: true,
                                                noMarker: true
                                            }
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Processor',
                                            content: processorName,
                                            width: 330
                                        },
                                        {
                                            title: 'vCPUs',
                                            content: numProcessingUnits,
                                            width: 70
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Load',
                                            content: '0% (1min avg)',
                                            width: 200,
                                            meter: {
                                                range: 400,
                                                value: 0,
                                                width: 200,
                                                ghost: true,
                                                noText: true
                                            }
                                        },
                                        {
                                            title: '',
                                            graph: {
                                                suffix: '%',
                                                resolution: 22,
                                                lookupPrecision: [100, 0],
                                                segments: [12, 10],
                                                ratio: [0.9, 0.1],
                                                range: 400,
                                                width: 200,
                                                height: 48,
                                                noMarker: true
                                            }
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Mem',
                                            content: `${memUsed} / ${memTotal} (${memUsedPercentage}%)`,
                                            width: 200,
                                            meter: {
                                                range: 100,
                                                value: memUsedPercentage,
                                                width: 200,
                                                noText: true
                                            }
                                        },
                                        {
                                            title: 'Swap',
                                            content: `${swapUsed} / ${swapTotal} (${swapUsedPercentage}%)`,
                                            width: 200,
                                            meter: {
                                                range: 100,
                                                value: swapUsedPercentage,
                                                width: 200,
                                                noText: true
                                            }
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Storage',
                                            content: `${storageUsed} / ${storageTotal} (${storageUsedPercentage}%)`,
                                            width: 200,
                                            meter: {
                                                range: 100,
                                                value: storageUsedPercentage,
                                                width: 200,
                                                noText: true
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    });
                    this.ui.css({ position: 'static' });
                    this.ui.details.css({ minWidth: 220 });
                    this.ui.animateIn();
                    document.body.appendChild(this.ui.element);

                    this.ui.detailsUptime = this.ui.details.content[2].children[1];
                    this.ui.detailsLatencyMeter = this.ui.details.content[3].children[1];

                    this.ui.detailsNumClients = this.ui.details.content[5].children[1];

                    this.ui.detailsLatencyAvg = this.ui.details.content[6].children[1];
                    this.ui.detailsLatencyAvgMeter = this.ui.details.content[6].children[2];
                    this.ui.detailsLatencyGraph = this.ui.details.content[7].children[1];

                    this.ui.detailsLoadAvg = this.ui.details.content[10].children[1];
                    this.ui.detailsLoadAvgMeter = this.ui.details.content[10].children[2];
                    this.ui.detailsLoadAvgGraph = this.ui.details.content[11].children[1];

                    this.ui.detailsMem = this.ui.details.content[12].children[1];
                    this.ui.detailsMemMeter = this.ui.details.content[12].children[2];

                    this.ui.detailsSwap = this.ui.details.content[13].children[1];
                    this.ui.detailsSwapMeter = this.ui.details.content[13].children[2];

                    this.ui.detailsStorage = this.ui.details.content[14].children[1];
                    this.ui.detailsStorageMeter = this.ui.details.content[14].children[2];

                    Data.init({ projectDomain, networkName });

                    this.initPanel();

                    Stage.events.emit('start');
                    window.addEventListener('keyup', this.onKeyUp);
                } else {
                    this.ui.detailsMem.html(`${memUsed} / ${memTotal} (${memUsedPercentage}%)`);
                    this.ui.detailsMemMeter.update(memUsedPercentage);

                    this.ui.detailsSwap.html(`${swapUsed} / ${swapTotal} (${swapUsedPercentage}%)`);
                    this.ui.detailsSwapMeter.update(swapUsedPercentage);

                    this.ui.detailsStorage.html(`${storageUsed} / ${storageTotal} (${storageUsedPercentage}%)`);
                    this.ui.detailsStorageMeter.update(storageUsedPercentage);
                }
            };

            static onData = ({ timestampData, latencyAvgData, loadAvgData, clientsData }) => {
                this.timestampData = new TimestampData();
                this.timestampData.setArrays(timestampData);
                this.timestampData.addMarker([this.restartTime, 'Restart']);

                this.latencyAvgData = new GraphData();
                this.latencyAvgData.setArrays(latencyAvgData);

                this.view.latencyAvgGraph.setGhostArray([...this.latencyAvgData.smallGhostArrayReversed, ...this.latencyAvgData.largeGhostArrayReversed]);
                this.view.latencyAvgGraph.setArray([...this.latencyAvgData.smallArrayReversed, ...this.latencyAvgData.largeArrayReversed]);

                this.loadAvgData = new GraphData();
                this.loadAvgData.setArrays(loadAvgData);

                this.ui.detailsLoadAvgGraph.setGhostArray([...this.loadAvgData.smallGhostArray, ...this.loadAvgData.realtimeGhostArray]);
                this.ui.detailsLoadAvgGraph.setArray([...this.loadAvgData.smallArray, ...this.loadAvgData.realtimeArray]);

                this.view.loadAvgGraph.setGhostArray([...this.loadAvgData.smallGhostArrayReversed, ...this.loadAvgData.largeGhostArrayReversed]);
                this.view.loadAvgGraph.setArray([...this.loadAvgData.smallArrayReversed, ...this.loadAvgData.largeArrayReversed]);

                this.clientsData = new GraphData();
                this.clientsData.setArrays(clientsData);

                this.view.clientsGraph.setGhostArray([...this.clientsData.smallGhostArrayReversed, ...this.clientsData.largeGhostArrayReversed]);
                this.view.clientsGraph.setArray([...this.clientsData.smallArrayReversed, ...this.clientsData.largeArrayReversed]);

                this.refresh();
            };

            static onStatus = ({ currentTime, serverUptimeFormatted, latency, latencyAvg, loadAvg, numClients }) => {
                if (this.timestampData && currentTime !== undefined) {
                    this.timestampData.update(currentTime);

                    if (this.timestampData.largeCounter === 0) {
                        this.refresh();
                    }
                }

                if (serverUptimeFormatted !== undefined) {
                    this.ui.detailsUptime.html(serverUptimeFormatted);
                }

                if (latency !== undefined) {
                    this.ui.detailsLatencyMeter.update(latency);
                    this.ui.detailsLatencyGraph.update(latency);
                }

                if (this.latencyAvgData && latencyAvg !== undefined) {
                    this.ui.detailsLatencyAvg.html(`${latencyAvg}ms (avg)`);
                    this.ui.detailsLatencyAvgMeter.update(latencyAvg);

                    this.latencyAvgData.update(latencyAvg);

                    if (this.latencyAvgData.smallCounter === 0) {
                        this.view.latencyAvgGraph.ghostArray.splice(0, 12, ...this.latencyAvgData.smallGhostArrayReversed);
                        this.view.latencyAvgGraph.array.splice(0, 12, ...this.latencyAvgData.smallArrayReversed);
                        this.view.latencyAvgGraph.needsUpdate = true;
                        this.view.latencyAvgGraph.graphNeedsUpdate = true;
                    }

                    if (this.latencyAvgData.largeCounter === 0) {
                        this.view.latencyAvgGraph.ghostArray.splice(-90, 90, ...this.latencyAvgData.largeGhostArrayReversed);
                        this.view.latencyAvgGraph.array.splice(-90, 90, ...this.latencyAvgData.largeArrayReversed);
                        this.view.latencyAvgGraph.needsUpdate = true;
                        this.view.latencyAvgGraph.graphNeedsUpdate = true;
                    }
                }

                if (this.loadAvgData && loadAvg !== undefined) {
                    this.ui.detailsLoadAvg.html(`${loadAvg}% (1min avg)`);
                    this.ui.detailsLoadAvgMeter.update(loadAvg);

                    this.loadAvgData.update(loadAvg);

                    this.ui.detailsLoadAvgGraph.ghostArray.splice(-10, 10, ...this.loadAvgData.realtimeGhostArray);
                    this.ui.detailsLoadAvgGraph.array.splice(-10, 10, ...this.loadAvgData.realtimeArray);
                    this.ui.detailsLoadAvgGraph.needsUpdate = true;

                    if (this.loadAvgData.smallCounter === 0) {
                        this.ui.detailsLoadAvgGraph.ghostArray.splice(0, 12, ...this.loadAvgData.smallGhostArray);
                        this.ui.detailsLoadAvgGraph.array.splice(0, 12, ...this.loadAvgData.smallArray);
                        this.ui.detailsLoadAvgGraph.graphNeedsUpdate = true;

                        this.view.loadAvgGraph.ghostArray.splice(0, 12, ...this.loadAvgData.smallGhostArrayReversed);
                        this.view.loadAvgGraph.array.splice(0, 12, ...this.loadAvgData.smallArrayReversed);
                        this.view.loadAvgGraph.needsUpdate = true;
                        this.view.loadAvgGraph.graphNeedsUpdate = true;
                    }

                    if (this.loadAvgData.largeCounter === 0) {
                        this.view.loadAvgGraph.ghostArray.splice(-90, 90, ...this.loadAvgData.largeGhostArrayReversed);
                        this.view.loadAvgGraph.array.splice(-90, 90, ...this.loadAvgData.largeArrayReversed);
                        this.view.loadAvgGraph.needsUpdate = true;
                        this.view.loadAvgGraph.graphNeedsUpdate = true;
                    }

                    this.ui.detailsLoadAvgGraph.update();
                }

                if (this.clientsData && numClients !== undefined) {
                    this.ui.detailsNumClients.html(numClients);

                    this.clientsData.update(numClients);

                    if (this.clientsData.smallCounter === 0) {
                        this.view.clientsGraph.ghostArray.splice(0, 12, ...this.clientsData.smallGhostArrayReversed);
                        this.view.clientsGraph.array.splice(0, 12, ...this.clientsData.smallArrayReversed);
                        this.view.clientsGraph.needsUpdate = true;
                        this.view.clientsGraph.graphNeedsUpdate = true;
                    }

                    if (this.clientsData.largeCounter === 0) {
                        this.view.clientsGraph.ghostArray.splice(-90, 90, ...this.clientsData.largeGhostArrayReversed);
                        this.view.clientsGraph.array.splice(-90, 90, ...this.clientsData.largeArrayReversed);
                        this.view.clientsGraph.needsUpdate = true;
                        this.view.clientsGraph.graphNeedsUpdate = true;
                    }
                }
            };

            static onKeyUp = e => {
                if (e.ctrlKey && e.keyCode >= 55 && e.keyCode <= 57) { // Ctrl 7-9
                    const index = e.keyCode - 55;
                    this.view.point.setPanelIndex('Graph', index);
                }
            };

            // Public methods

            static refresh = () => {
                this.view.latencyAvgGraph.setData([[], this.timestampData.labelsArrayReversed]);
                this.view.loadAvgGraph.setData([[], this.timestampData.labelsArrayReversed]);
                this.view.clientsGraph.setData([[], this.timestampData.labelsArrayReversed]);

                const markers = this.timestampData.markersArrayReversed.map(data => {
                    data[0] = data[0] * 0.875; // 0.875 segment ratio
                    return data;
                });
                this.view.latencyAvgGraph.setMarkers(markers, true);
                this.view.loadAvgGraph.setMarkers(markers, true);
                this.view.clientsGraph.setMarkers(markers, true);

                // Cleanup
                markers.length = 0;
            };

            static update = () => {
                if (this.ui) {
                    this.ui.update();
                    this.ui.detailsLatencyGraph.update();
                    this.ui.detailsLoadAvgGraph.update();
                }
            };
        }

        class CameraController {
            static init(worldCamera, mapCamera, pointCamera) {
                this.worldCamera = worldCamera;
                this.mapCamera = mapCamera;
                this.pointCamera = pointCamera;

                // Default camera
                this.camera = this.mapCamera;

                this.progress = 0;
                this.isTransitioning = false;
            }

            static transition() {
                const target = this.target;

                this.progress = 0;

                tween(this, { progress: 1 }, 1000, 'easeInOutSine', () => {
                    this.camera = target;

                    if (this.target !== this.camera) {
                        this.transition();
                    } else {
                        this.isTransitioning = false;
                    }
                }, () => {
                    lerpCameras(this.worldCamera, target, this.progress);
                    this.worldCamera.view.offsetX = MathUtils.lerp(this.worldCamera.view.offsetX, target === this.pointCamera ? this.offsetX : 0, this.progress);
                    this.worldCamera.updateProjectionMatrix();
                });
            }

            // Public methods

            static setCamera = camera => {
                // this.camera = camera;
                this.target = camera;

                if (!this.isTransitioning) {
                    this.isTransitioning = true;

                    this.transition();
                }
            };

            static resize = (width, height) => {
                this.offsetX = -width / 4;

                // World camera
                this.worldCamera.aspect = width / height;
                this.worldCamera.setViewOffset(width, height, this.camera === this.pointCamera ? this.offsetX : 0, 0, width, height);
                this.worldCamera.updateProjectionMatrix();

                // Map camera
                this.mapCamera.aspect = width / height;
                this.mapCamera.updateProjectionMatrix();

                // Point of interest camera
                this.pointCamera.aspect = width / height;
                this.pointCamera.updateProjectionMatrix();
            };

            static update = () => {
                if (this.isTransitioning) {
                    return;
                }

                this.worldCamera.position.copy(this.camera.position);
                this.worldCamera.quaternion.copy(this.camera.quaternion);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({ antialias: true });

                // Output canvas
                this.element = this.renderer.domElement;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);

                // World camera
                this.camera = new PerspectiveCamera(35);
                this.camera.near = 1;
                this.camera.far = 2000;
                this.camera.position.z = 10;

                // Map camera
                this.mapCamera = this.camera.clone();

                // Point of interest camera
                this.pointCamera = this.camera.clone();
                this.pointCamera.position.z = 6;
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0xffffff, 0x888888, 3));
            }

            static initControls() {
                // Map controls
                this.mapControls = new OrbitControls(this.mapCamera, this.renderer.domElement);
                this.mapControls.enableDamping = true;
                this.mapControls.enabled = false;

                // Point of interest controls
                this.poiControls = new OrbitControls(this.pointCamera, this.renderer.domElement);
                this.poiControls.enableDamping = true;
                this.poiControls.enablePan = false;
                this.poiControls.enabled = false;

                // Output camera controls
                this.controls = this.mapControls;
                this.controls.enabled = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static setControls = controls => {
                this.controls = controls;

                this.mapControls.enabled = false;
                this.poiControls.enabled = false;

                this.controls.enabled = true;
            };

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.trackers = new TrackersView();
                document.body.appendChild(this.trackers.element);
            }

            static initControllers() {
                const { camera, mapCamera, pointCamera } = WorldController;

                CameraController.init(camera, mapCamera, pointCamera);
                SceneController.init(this.view);
                ServerStatusController.init(this.view, this.trackers);
            }

            static addListeners() {
                Stage.events.on('start', this.onStart);
            }

            // Event handlers

            static onStart = () => {
                Stage.events.on('details', this.onDetails);
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            };

            static onDetails = ({ open }) => {
                let camera;
                let controls;

                if (open) {
                    camera = WorldController.pointCamera;
                    controls = WorldController.poiControls;
                } else {
                    camera = WorldController.mapCamera;
                    controls = WorldController.mapControls;
                }

                CameraController.setCamera(camera);
                WorldController.setControls(controls);
            };

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update(time);
                PanelController.update(time);
                ServerStatusController.update(time);
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>
