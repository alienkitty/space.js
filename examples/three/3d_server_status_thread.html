<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <title>Server Status Thread â€” Space.js</title>

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:wght@300&family=Gothic+A1:wght@500;700">
    <link rel="stylesheet" href="../assets/css/style.css">

    <style>
        *, :after, :before {
            touch-action: unset;
        }

        body {
            position: unset;
            -moz-osx-font-smoothing: auto;
            -webkit-font-smoothing: auto;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three/build/three.module.js",
                "three/addons/": "https://unpkg.com/three/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import { BoxGeometry, Color, Group, HemisphereLight, MathUtils, Mesh, MeshNormalMaterial, PerspectiveCamera, Scene, WebGLRenderer } from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        import { EventEmitter, Interface, Menu, Point3D, RadialGraphContainer, RadialGraphSegmentsCanvas, Stage, Thread, UI, average, consecutive, delayedCall, lerpCameras, median, peaks, ticker, tween } from '../../src/three.js';

        const isDebug = /[?&]debug/.test(location.search);

        class Data {
            static init({ projectDomain, networkName }) {
                this.projectDomain = projectDomain;
                this.networkName = networkName;
            }

            // Public methods

            static getName = () => {
                // return basename(this.projectDomain);
                return 'server-status';
            };

            static getType = () => {
                return this.networkName.match(/\(([^)]+)\)/).pop();
            };
        }

        class GraphData {
            constructor() {
                // Graph averages
                this.ghostArray = [];
                this.array = [];
                this.largeGhostArray = [];
                this.largeArray = [];
                this.smallGhostArray = [];
                this.smallArray = [];

                // Median downsample
                this.largeChunkSize = 200;
                this.smallChunkSize = 10;
                this.realtimeCounter = 0;
            }

            // Public methods

            setData = data => {
                this.data = data;

                // Last 320 status updates for small graph (160 + 160, ghost + array)
                data = data.slice(-320);
                this.ghostArray = data.slice(0, 160);
                this.array = data.slice(-160);

                // Last 20 status updates for realtime graph (10 + 10, ghost + array)
                const realtimeData = data.slice(-20);
                this.realtimeGhostArray = realtimeData.slice(0, 10);
                this.realtimeArray = realtimeData.slice(-10);

                // Large median downsample
                const array = [];

                for (let i = 0; i < this.data.length; i += this.largeChunkSize) {
                    array.push(median(this.data.slice(i, i + this.largeChunkSize)));
                }

                // Past day (21488 status updates) downsampled to 108 (54 + 54, ghost + array)
                this.largeArray = array.splice(-54, 54);
                this.largeGhostArray = array.splice(-54, 54);

                // Small median downsample
                array.length = 0;

                for (let i = 0; i < data.length; i += this.smallChunkSize) {
                    array.push(median(data.slice(i, i + this.smallChunkSize)));
                }

                // Last 320 status updates downsampled to 32 (16 + 16, ghost + array)
                this.smallGhostArray = array.slice(0, 16);
                this.smallArray = array.slice(-16);
            };

            getArrays = () => ({
                ghostArray: this.ghostArray,
                array: this.array,
                largeGhostArray: this.largeGhostArray,
                largeArray: this.largeArray,
                smallGhostArray: this.smallGhostArray,
                smallArray: this.smallArray,
                realtimeGhostArray: this.realtimeGhostArray,
                realtimeArray: this.realtimeArray
            });

            setArrays = ({
                ghostArray,
                array,
                largeGhostArray,
                largeArray,
                smallGhostArray,
                smallArray,
                realtimeGhostArray,
                realtimeArray
            }) => {
                this.ghostArray = ghostArray;
                this.array = array;
                this.largeGhostArray = largeGhostArray;
                this.largeArray = largeArray;
                this.smallGhostArray = smallGhostArray;
                this.smallArray = smallArray;
                this.realtimeGhostArray = realtimeGhostArray;
                this.realtimeArray = realtimeArray;
            };

            getPeaks = threshold => {
                // Past 12hrs (10744 status updates)
                const groups = consecutive(peaks(this.data.slice(-10744), this.largeChunkSize / 2, threshold));

                return groups.map(array => array[0] / 10744); // First index normalized
            };

            update = value => {
                const ghost = this.array.shift();
                this.array.push(value);
                this.ghostArray.shift();
                this.ghostArray.push(ghost);

                // Last 20 status updates for realtime graph (10 + 10, ghost + array)
                const realtimeData = this.array.slice(-20);
                this.realtimeGhostArray = realtimeData.slice(0, 10);
                this.realtimeArray = realtimeData.slice(-10);

                // Small median downsample
                if (++this.realtimeCounter === this.smallChunkSize) {
                    const medianGhost = this.smallArray.shift();
                    this.smallArray.push(median(this.realtimeArray));
                    this.smallGhostArray.shift();
                    this.smallGhostArray.push(medianGhost);

                    this.realtimeCounter = 0;
                }
            };
        }

        class Socket extends EventEmitter {
            constructor(server) {
                super();

                this.server = server;

                this.connected = false;

                // Latency average
                this.latencyArray = [];

                this.connect();
            }

            addListeners() {
                this.socket.addEventListener('open', this.onOpen);
                this.socket.addEventListener('close', this.onClose);
                this.socket.addEventListener('message', this.onMessage);
            }

            removeListeners() {
                this.socket.removeEventListener('open', this.onOpen);
                this.socket.removeEventListener('close', this.onClose);
                this.socket.removeEventListener('message', this.onMessage);
            }

            // Event handlers

            onOpen = () => {
                this.connected = true;

                const event = 'subscribe';
                const message = {
                    subscription: {
                        name: 'server-status',
                        time: 86400 // Past day in seconds
                    }
                };

                console.log('send', event, message);
                this.send({ event, message });
            };

            onClose = () => {
                console.log('close');
                this.connected = false;

                delayedCall(250, this.connect);
            };

            onMessage = ({ data }) => {
                const { event, message } = JSON.parse(data);
                console.log('message', event, message);

                switch (event) {
                    case 'heartbeat':
                        this.send({ event, message });
                        break;
                    case 'server-details': {
                        const { details/* , latency */ } = message;

                        const {
                            // packageVersion,
                            projectDomain,
                            networkName,
                            serverVersion,
                            memTotal,
                            memFree,
                            swapTotal,
                            swapFree,
                            storageTotal,
                            storageAvailable,
                            processorName,
                            numProcessingUnits,
                            numClients
                        } = details;

                        const memUsed = memTotal - memFree;

                        let memUsedFormatted = memUsed / 1024 / 1024 / 1024;
                        memUsedFormatted = `${Math.round((memUsedFormatted + Number.EPSILON) * 100) / 100} GiB`;

                        let memTotalFormatted = memTotal / 1024 / 1024 / 1024;
                        memTotalFormatted = `${Math.round((memTotalFormatted + Number.EPSILON) * 100) / 100} GiB`;

                        let memUsedPercentage = (memUsed / memTotal) * 100;
                        memUsedPercentage = Math.round((memUsedPercentage + Number.EPSILON) * 100) / 100;

                        const swapUsed = swapTotal - swapFree;

                        let swapUsedFormatted = swapUsed / 1024 / 1024 / 1024;
                        swapUsedFormatted = `${Math.round((swapUsedFormatted + Number.EPSILON) * 100) / 100} GiB`;

                        let swapTotalFormatted = swapTotal / 1024 / 1024 / 1024;
                        swapTotalFormatted = `${Math.round((swapTotalFormatted + Number.EPSILON) * 100) / 100} GiB`;

                        let swapUsedPercentage = (swapUsed / swapTotal) * 100;
                        swapUsedPercentage = Math.round((swapUsedPercentage + Number.EPSILON) * 100) / 100;

                        const storageUsed = storageTotal - storageAvailable;

                        let storageUsedFormatted;
                        let storageTotalFormatted;

                        if (storageTotal < 1e9) {
                            storageUsedFormatted = storageUsed / 1000 / 1000;
                            storageUsedFormatted = `${Math.round((storageUsedFormatted + Number.EPSILON) * 100) / 100} MB`;

                            storageTotalFormatted = storageTotal / 1000 / 1000;
                            storageTotalFormatted = `${Math.round((storageTotalFormatted + Number.EPSILON) * 100) / 100} MB`;
                        } else {
                            storageUsedFormatted = storageUsed / 1000 / 1000 / 1000;
                            storageUsedFormatted = `${Math.round((storageUsedFormatted + Number.EPSILON) * 100) / 100} GB`;

                            storageTotalFormatted = storageTotal / 1000 / 1000 / 1000;
                            storageTotalFormatted = `${Math.round((storageTotalFormatted + Number.EPSILON) * 100) / 100} GB`;
                        }

                        let storageUsedPercentage = (storageUsed / storageTotal) * 100;
                        storageUsedPercentage = Math.round((storageUsedPercentage + Number.EPSILON) * 100) / 100;

                        this.emit('details', {
                            projectDomain,
                            networkName,
                            serverVersion,
                            memUsed: memUsedFormatted,
                            memTotal: memTotalFormatted,
                            memUsedPercentage,
                            swapUsed: swapUsedFormatted,
                            swapTotal: swapTotalFormatted,
                            swapUsedPercentage,
                            storageUsed: storageUsedFormatted,
                            storageTotal: storageTotalFormatted,
                            storageUsedPercentage,
                            processorName,
                            numProcessingUnits,
                            numClients: numClients > 0 ? numClients : 1
                        });
                        break;
                    }
                    case 'server-status': {
                        const { status, latency } = message;

                        let data = status;

                        // Initial data dump
                        if (data.length > 3) {
                            // Separate last status update as new update
                            const last = data.pop();

                            // Latency average data (initially no data, all 0s)
                            this.latencyAvgData = new GraphData();
                            this.latencyAvgData.setData(new Array(data.length).fill(0));

                            // Load average data
                            this.loadAvgData = new GraphData();
                            this.loadAvgData.setData(data.map(data => data[2] * 100)); // percentage

                            // Server uptime data
                            this.serverUptimeData = new GraphData();
                            this.serverUptimeData.setData(data.map(data => data[1])); // server uptime in seconds

                            this.emit('data', {
                                latencyAvgData: this.latencyAvgData.getArrays(),
                                loadAvgData: this.loadAvgData.getArrays(),
                                serverUptimeData: this.serverUptimeData.getArrays()
                            });

                            data = last;
                        }

                        if (latency !== undefined) {
                            this.latencyArray.push(latency);
                        }

                        const serverUptime = data[1];

                        // https://stackoverflow.com/questions/36098913/convert-seconds-to-days-hours-minutes-and-seconds/52387803#52387803
                        const days = Math.floor(serverUptime / (3600 * 24));
                        const hours = Math.floor(serverUptime % (3600 * 24) / 3600);
                        const minutes = Math.floor(serverUptime % 3600 / 60);
                        const seconds = Math.floor(serverUptime % 60);

                        const daysFormatted = days > 0 ? days + (days === 1 ? ' day ' : ' days ') : '';
                        const hoursFormatted = hours > 0 ? hours + (hours === 1 ? ' hour ' : ' hours ') : '';
                        const minutesFormatted = minutes > 0 ? minutes + (minutes === 1 ? ' minute ' : ' minutes ') : '';
                        const secondsFormatted = seconds > 0 ? seconds + (seconds === 1 ? ' second' : ' seconds') : '';

                        const serverUptimeFormatted = daysFormatted + hoursFormatted + minutesFormatted + secondsFormatted;

                        let latencyAvg;

                        if (this.latencyArray.length) {
                            latencyAvg = Math.round(average(this.latencyArray));
                        }

                        let loadAvg = data[2] * 100; // percentage
                        loadAvg = Math.round(loadAvg);

                        this.emit('status', { serverUptime, serverUptimeFormatted, latency, latencyAvg, loadAvg });
                        break;
                    }
                }
            };

            // Public methods

            getPeaks = (name, threshold) => {
                return this[name].getPeaks(threshold);
            };

            send = data => {
                if (!this.connected) {
                    return;
                }

                this.socket.send(JSON.stringify(data));
            };

            connect = () => {
                if (this.socket) {
                    this.close();
                }

                this.socket = new WebSocket(this.server, ['permessage-deflate']);

                this.addListeners();
            };

            close = () => {
                this.removeListeners();

                this.socket.close();
            };
        }

        class SocketThread {
            constructor() {
                this.addListeners();
            }

            addListeners() {
                addEventListener('message', this.onMessage);
            }

            // Event handlers

            onMessage = ({ data }) => {
                this[data.message.fn].call(this, data.message);
            };

            onOpen = () => {
                postMessage({ event: 'open' });
            };

            onClose = () => {
                postMessage({ event: 'close' });
            };

            onDetails = e => {
                postMessage({ event: 'details', message: e });
            };

            onData = e => {
                postMessage({ event: 'data', message: e });
            };

            onStatus = e => {
                postMessage({ event: 'status', message: e });
            };

            // Public methods

            init = ({ server }) => {
                this.socket = new Socket(server);
                this.socket.on('open', this.onOpen);
                this.socket.on('close', this.onClose);
                this.socket.on('details', this.onDetails);
                this.socket.on('data', this.onData);
                this.socket.on('status', this.onStatus);
            };

            getPeaks = ({ name, threshold, id }) => {
                postMessage({ id, message: this.socket.getPeaks(name, threshold) });
            };
        }

        class TrackersView extends Interface {
            constructor() {
                super('.trackers');

                this.init();
            }

            init() {
                this.css({
                    position: 'fixed',
                    left: 0,
                    top: 0,
                    width: '100%',
                    height: '100%',
                    pointerEvents: 'none',
                    webkitUserSelect: 'none',
                    userSelect: 'none'
                });
            }
        }

        class SceneView extends Group {
            constructor() {
                super();

                this.initMesh();
            }

            initMesh() {
                const geometry = new BoxGeometry();
                geometry.computeTangents();

                const material = new MeshNormalMaterial();

                const mesh = new Mesh(geometry, material);
                this.add(mesh);

                this.mesh = mesh;
            }

            // Public methods

            update = time => {
                this.mesh.rotation.x = time / 2;
                this.mesh.rotation.y = time;
            };
        }

        class SceneController {
            static init(view) {
                this.view = view;
            }

            // Public methods

            static update = time => {
                this.view.update(time);
            };
        }

        class ScenePanelController {
            static init(view, ui) {
                this.view = view;
                this.ui = ui;

                this.initPanel();

                this.addListeners();
            }

            static initPanel() {
                const view = this.view;

                const objects = [view];

                objects.forEach(object => {
                    // Note the `start` and `graphHeight` parameters are used for the point position
                    object.graph = new RadialGraphContainer({
                        start: -45,
                        graphHeight: 40
                    });

                    object.latencyAvgGraph = new RadialGraphSegmentsCanvas({
                        start: -45,
                        graphHeight: 40,
                        resolution: 70,
                        tension: 12,
                        lookupPrecision: [25, 100],
                        segments: [16, 54],
                        ratio: [0.125, 0.875], // 45 / 360 = 0.125
                        labels: ['Latency', '12hrs'],
                        range: 300,
                        labelDistance: 30,
                        suffix: 'ms',
                        noMarkerDrag: true
                    });
                    object.graph.add(object.latencyAvgGraph);

                    object.loadAvgGraph = new RadialGraphSegmentsCanvas({
                        start: -45,
                        graphHeight: 40,
                        resolution: 70,
                        tension: 6,
                        lookupPrecision: [25, 100],
                        segments: [16, 54],
                        ratio: [0.125, 0.875], // 45 / 360 = 0.125
                        labels: ['Load', '12hrs'],
                        range: 400,
                        labelDistance: 30,
                        suffix: '%',
                        noMarkerDrag: true
                    });
                    object.graph.add(object.loadAvgGraph);

                    object.serverUptimeGraph = new RadialGraphSegmentsCanvas({
                        start: -45,
                        graphHeight: 40,
                        resolution: 70,
                        tension: 12,
                        lookupPrecision: [25, 100],
                        segments: [16, 54],
                        ratio: [0.125, 0.875], // 45 / 360 = 0.125
                        labels: ['Uptime', '12hrs'],
                        range: 60000, // ~16hrs in seconds
                        infoDistanceX: 30,
                        labelDistance: 30,
                        suffix: 's',
                        noMarkerDrag: true
                    });
                    object.graph.add(object.serverUptimeGraph);

                    // Default graph (load average)
                    object.graph.setIndex(1);

                    object.point = new Point3D(object.mesh, {
                        name: Data.getName(),
                        type: Data.getType(),
                        graph: object.graph,
                        noTracker: true
                    });
                    object.add(object.point);
                });

                // Shrink tracker mesh to better match the visual size of the object
                view.point.mesh.scale.multiplyScalar(0.8);
            }

            static addListeners() {
                Point3D.events.on('click', this.onClick);
            }

            // Event handlers

            static onClick = () => {
                this.ui.toggleDetails(!this.ui.details.animatedIn);

                Point3D.animateOut();
            };
        }

        class PanelController {
            static init(renderer, scene, camera, view, trackers, ui) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                this.view = view;
                this.trackers = trackers;
                this.ui = ui;

                this.initControllers();
            }

            static initControllers() {
                Point3D.init(this.renderer, this.scene, this.camera, {
                    container: this.trackers,
                    dividerSnap: this.ui.details.dividerLine,
                    debug: isDebug
                });

                ScenePanelController.init(this.view, this.ui);
            }

            // Public methods

            static update = time => {
                if (!this.ui) {
                    return;
                }

                Point3D.update(time);
            };
        }

        class ServerStatusController {
            static init(view, trackers) {
                this.view = view;
                this.trackers = trackers;

                this.initSocket();

                this.addListeners();
            }

            static initSocket() {
                const server = 'wss://hello-websockets-server-status.glitch.me';

                this.thread = new Thread({
                    imports: [
                        // TODO: Investigate why the `three` entry point fails
                        // ['../../src/three.js', 'EventEmitter', 'average', 'consecutive', 'delayedCall', 'median', 'peaks']
                        ['../../src/index.js', 'EventEmitter', 'average', 'consecutive', 'delayedCall', 'median', 'peaks']
                    ],
                    classes: [GraphData, Socket],
                    controller: [SocketThread, 'init', 'getPeaks']
                });
                this.thread.init({ server });
            }

            static initPanel() {
                const { renderer, scene, camera } = WorldController;

                PanelController.init(renderer, scene, camera, this.view, this.trackers, this.ui);
            }

            static addListeners() {
                Stage.events.on('details', this.onDetails);
                Stage.events.on('ui', this.onUI);
                this.thread.on('details', this.onServerDetails);
                this.thread.on('data', this.onServerData);
                this.thread.on('status', this.onServerStatus);
            }

            // Event handlers

            static onDetails = ({ open }) => {
                if (open) {
                    this.menu.animateIn();
                } else {
                    this.menu.animateOut();
                }
            };

            static onUI = ({ open }) => {
                if (!open) {
                    this.menu.animateOut();
                }
            };

            static onServerDetails = ({
                projectDomain,
                networkName,
                serverVersion,
                memUsed,
                memTotal,
                memUsedPercentage,
                swapUsed,
                swapTotal,
                swapUsedPercentage,
                storageUsed,
                storageTotal,
                storageUsedPercentage,
                processorName,
                numProcessingUnits,
                numClients
            }) => {
                if (!this.ui) {
                    this.ui = new UI({
                        fps: true,
                        details: {
                            dividerLine: true,
                            width: '50vw',
                            title: 'server-status'.replace(/[\s.-]+/g, '_'),
                            content: [
                                {
                                    content: 'A simple status API endpoint built on Express, like the Apache status page.',
                                    links: [
                                        {
                                            title: 'Source code',
                                            link: 'https://github.com/pschroen/hello-websockets-server-status'
                                        }
                                    ],
                                    width: '100%'
                                },
                                {
                                    group: [
                                        {
                                            title: 'Server version',
                                            content: serverVersion,
                                            width: 110
                                        },
                                        {
                                            title: 'Uptime',
                                            content: '',
                                            width: 200
                                        },
                                        {
                                            title: 'Latency',
                                            meter: {
                                                suffix: 'ms',
                                                range: 150,
                                                value: 0,
                                                width: 70,
                                                noRange: true
                                            }
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Network',
                                            content: `${projectDomain}<br>${networkName}`,
                                            width: 330
                                        },
                                        {
                                            title: 'Clients',
                                            content: numClients,
                                            width: 70
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Latency',
                                            content: '0ms (avg)',
                                            width: 200,
                                            meter: {
                                                range: 300,
                                                value: 0,
                                                width: 200,
                                                ghost: true,
                                                noText: true
                                            }
                                        },
                                        {
                                            title: '',
                                            graph: {
                                                suffix: 'ms',
                                                resolution: 160,
                                                range: 300,
                                                width: 200,
                                                height: 48,
                                                ghost: true,
                                                noMarker: true
                                            }
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Processor',
                                            content: processorName,
                                            width: 330
                                        },
                                        {
                                            title: 'vCPUs',
                                            content: numProcessingUnits,
                                            width: 70
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Load',
                                            content: '0% (1min avg)',
                                            width: 200,
                                            meter: {
                                                range: 400,
                                                value: 0,
                                                width: 200,
                                                ghost: true,
                                                noText: true
                                            }
                                        },
                                        {
                                            title: '',
                                            graph: {
                                                suffix: '%',
                                                resolution: 26,
                                                lookupPrecision: [100, 0],
                                                segments: [16, 10],
                                                ratio: [0.9, 0.1],
                                                range: 400,
                                                width: 200,
                                                height: 48,
                                                noMarker: true
                                            }
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Mem',
                                            content: `${memUsed} / ${memTotal} (${memUsedPercentage}%)`,
                                            width: 200,
                                            meter: {
                                                range: 100,
                                                value: memUsedPercentage,
                                                width: 200,
                                                noText: true
                                            }
                                        },
                                        {
                                            title: 'Swap',
                                            content: `${swapUsed} / ${swapTotal} (${swapUsedPercentage}%)`,
                                            width: 200,
                                            meter: {
                                                range: 100,
                                                value: swapUsedPercentage,
                                                width: 200,
                                                noText: true
                                            }
                                        }
                                    ]
                                },
                                {
                                    group: [
                                        {
                                            title: 'Storage',
                                            content: `${storageUsed} / ${storageTotal} (${storageUsedPercentage}%)`,
                                            width: 200,
                                            meter: {
                                                range: 100,
                                                value: storageUsedPercentage,
                                                width: 200,
                                                noText: true
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    });
                    this.ui.css({ position: 'static' });
                    this.ui.details.css({ minWidth: 220 });
                    this.ui.animateIn();

                    this.container = new Interface('.container');
                    this.container.css({
                        position: 'fixed',
                        left: '50vw',
                        top: 0,
                        width: '50vw',
                        height: '100%',
                        pointerEvents: 'none'
                    });
                    this.ui.add(this.container);

                    this.menu = new Menu({
                        bottom: true,
                        itemWidth: 74,
                        items: ['Latency', 'Load', 'Uptime'],
                        // items: ['Uptime', 'Load', 'Clients'],
                        active: 'Load'
                    });
                    this.menu.css({ position: 'absolute' });
                    this.menu.events.on('update', this.onMenu);
                    this.container.add(this.menu);

                    document.body.appendChild(this.ui.element);

                    this.ui.detailsUptime = this.ui.details.content[2].children[1];
                    this.ui.detailsLatencyMeter = this.ui.details.content[3].children[1];

                    this.ui.detailsNumClients = this.ui.details.content[5].children[1];

                    this.ui.detailsLatencyAvg = this.ui.details.content[6].children[1];
                    this.ui.detailsLatencyAvgMeter = this.ui.details.content[6].children[2];
                    this.ui.detailsLatencyGraph = this.ui.details.content[7].children[1];

                    this.ui.detailsLoadAvg = this.ui.details.content[10].children[1];
                    this.ui.detailsLoadAvgMeter = this.ui.details.content[10].children[2];
                    this.ui.detailsLoadAvgGraph = this.ui.details.content[11].children[1];

                    this.ui.detailsMem = this.ui.details.content[12].children[1];
                    this.ui.detailsMemMeter = this.ui.details.content[12].children[2];

                    this.ui.detailsSwap = this.ui.details.content[13].children[1];
                    this.ui.detailsSwapMeter = this.ui.details.content[13].children[2];

                    this.ui.detailsStorage = this.ui.details.content[14].children[1];
                    this.ui.detailsStorageMeter = this.ui.details.content[14].children[2];

                    Data.init({ projectDomain, networkName });

                    this.initPanel();

                    Stage.events.emit('start');
                    window.addEventListener('keyup', this.onKeyUp);
                    window.dispatchEvent(new Event('resize'));
                } else {
                    this.ui.detailsNumClients.html(numClients);

                    this.ui.detailsMem.html(`${memUsed} / ${memTotal} (${memUsedPercentage}%)`);
                    this.ui.detailsMemMeter.update(memUsedPercentage);

                    this.ui.detailsSwap.html(`${swapUsed} / ${swapTotal} (${swapUsedPercentage}%)`);
                    this.ui.detailsSwapMeter.update(swapUsedPercentage);

                    this.ui.detailsStorage.html(`${storageUsed} / ${storageTotal} (${storageUsedPercentage}%)`);
                    this.ui.detailsStorageMeter.update(storageUsedPercentage);
                }
            };

            static onServerData = async ({ latencyAvgData, loadAvgData, serverUptimeData }) => {
                this.latencyAvgData = new GraphData();
                this.latencyAvgData.setArrays(latencyAvgData);

                this.view.latencyAvgGraph.setGhostArray([...this.latencyAvgData.smallGhostArray.toReversed(), ...this.latencyAvgData.largeGhostArray.toReversed()]);
                this.view.latencyAvgGraph.setArray([...this.latencyAvgData.smallArray.toReversed(), ...this.latencyAvgData.largeArray.toReversed()]);

                this.loadAvgData = new GraphData();
                this.loadAvgData.setArrays(loadAvgData);

                this.view.loadAvgGraph.setGhostArray([...this.loadAvgData.smallGhostArray.toReversed(), ...this.loadAvgData.largeGhostArray.toReversed()]);
                this.view.loadAvgGraph.setArray([...this.loadAvgData.smallArray.toReversed(), ...this.loadAvgData.largeArray.toReversed()]);

                this.ui.detailsLoadAvgGraph.setGhostArray([...this.loadAvgData.smallGhostArray, ...this.loadAvgData.realtimeGhostArray]);
                this.ui.detailsLoadAvgGraph.setArray([...this.loadAvgData.smallArray, ...this.loadAvgData.realtimeArray]);

                this.serverUptimeData = new GraphData();
                this.serverUptimeData.setArrays(serverUptimeData);

                this.view.serverUptimeGraph.setGhostArray([...this.serverUptimeData.smallGhostArray.toReversed(), ...this.serverUptimeData.largeGhostArray.toReversed()]);
                this.view.serverUptimeGraph.setArray([...this.serverUptimeData.smallArray.toReversed(), ...this.serverUptimeData.largeArray.toReversed()]);

                let peaks = await this.thread.getPeaks({ name: 'serverUptimeData', threshold: 20000 });
                peaks = peaks.map(value => 1 - value); // reversed
                peaks.forEach(angle => this.view.serverUptimeGraph.addMarker([angle * 0.875, 'Restart'])); // 0.875 segment ratio
            };

            static onServerStatus = ({ serverUptime, serverUptimeFormatted, latency, latencyAvg, loadAvg }) => {
                if (this.serverUptimeData && serverUptime !== undefined) {
                    this.serverUptimeData.update(serverUptime);

                    if (this.serverUptimeData.realtimeCounter === 0) {
                        this.view.serverUptimeGraph.ghostArray.splice(0, 16, ...this.serverUptimeData.smallGhostArray.toReversed());
                        this.view.serverUptimeGraph.array.splice(0, 16, ...this.serverUptimeData.smallArray.toReversed());
                        this.view.serverUptimeGraph.needsUpdate = true;
                        this.view.serverUptimeGraph.graphNeedsUpdate = true;
                    }
                }

                if (serverUptimeFormatted !== undefined) {
                    this.ui.detailsUptime.html(serverUptimeFormatted);
                }

                if (latency !== undefined) {
                    this.ui.detailsLatencyMeter.update(latency);
                    this.ui.detailsLatencyGraph.update(latency);
                }

                if (this.latencyAvgData && latencyAvg !== undefined) {
                    this.ui.detailsLatencyAvg.html(`${latencyAvg}ms (avg)`);
                    this.ui.detailsLatencyAvgMeter.update(latencyAvg);

                    this.latencyAvgData.update(latencyAvg);

                    if (this.latencyAvgData.realtimeCounter === 0) {
                        this.view.latencyAvgGraph.ghostArray.splice(0, 16, ...this.latencyAvgData.smallGhostArray.toReversed());
                        this.view.latencyAvgGraph.array.splice(0, 16, ...this.latencyAvgData.smallArray.toReversed());
                        this.view.latencyAvgGraph.needsUpdate = true;
                        this.view.latencyAvgGraph.graphNeedsUpdate = true;
                    }
                }

                if (this.loadAvgData && loadAvg !== undefined) {
                    this.ui.detailsLoadAvg.html(`${loadAvg}% (1min avg)`);
                    this.ui.detailsLoadAvgMeter.update(loadAvg);

                    this.loadAvgData.update(loadAvg);

                    this.ui.detailsLoadAvgGraph.ghostArray.splice(-10, 10, ...this.loadAvgData.realtimeGhostArray);
                    this.ui.detailsLoadAvgGraph.array.splice(-10, 10, ...this.loadAvgData.realtimeArray);
                    this.ui.detailsLoadAvgGraph.needsUpdate = true;

                    if (this.loadAvgData.realtimeCounter === 0) {
                        this.view.loadAvgGraph.ghostArray.splice(0, 16, ...this.loadAvgData.smallGhostArray.toReversed());
                        this.view.loadAvgGraph.array.splice(0, 16, ...this.loadAvgData.smallArray.toReversed());
                        this.view.loadAvgGraph.needsUpdate = true;
                        this.view.loadAvgGraph.graphNeedsUpdate = true;

                        this.ui.detailsLoadAvgGraph.ghostArray.splice(0, 16, ...this.loadAvgData.smallGhostArray);
                        this.ui.detailsLoadAvgGraph.array.splice(0, 16, ...this.loadAvgData.smallArray);
                        this.ui.detailsLoadAvgGraph.graphNeedsUpdate = true;
                    }

                    this.ui.detailsLoadAvgGraph.update();
                }
            };

            static onMenu = ({ index }) => {
                this.view.graph.setIndex(index);
            };

            static onKeyUp = e => {
                if (e.ctrlKey && e.keyCode >= 55 && e.keyCode <= 57) { // Ctrl 7-9
                    this.menu.index = e.keyCode - 55;
                    this.menu.update();
                }
            };

            // Public methods

            static resize = (width, height, dpr) => {
                if (this.ui) {
                    this.menu.resize(width, height, dpr, this.ui.breakpoint);
                }
            };

            static update = () => {
                if (this.ui) {
                    this.ui.update();
                    this.ui.detailsLatencyGraph.update();
                    this.ui.detailsLoadAvgGraph.update();
                }
            };
        }

        class CameraController {
            static init(worldCamera, mapCamera, pointCamera) {
                this.worldCamera = worldCamera;
                this.mapCamera = mapCamera;
                this.pointCamera = pointCamera;

                // Default camera
                this.camera = this.mapCamera;

                this.progress = 0;
                this.isTransitioning = false;
            }

            static transition() {
                const target = this.target;

                this.progress = 0;

                tween(this, { progress: 1 }, 1000, 'easeInOutSine', () => {
                    this.camera = target;

                    if (this.target !== this.camera) {
                        this.transition();
                    } else {
                        this.isTransitioning = false;
                    }
                }, () => {
                    lerpCameras(this.worldCamera, target, this.progress);
                    this.worldCamera.view.offsetX = MathUtils.lerp(this.worldCamera.view.offsetX, target === this.pointCamera ? this.offsetX : 0, this.progress);
                    this.worldCamera.updateProjectionMatrix();
                });
            }

            // Public methods

            static setCamera = camera => {
                // this.camera = camera;
                this.target = camera;

                if (!this.isTransitioning) {
                    this.isTransitioning = true;

                    this.transition();
                }
            };

            static resize = (width, height) => {
                this.offsetX = -width / 4;

                // World camera
                this.worldCamera.aspect = width / height;
                this.worldCamera.setViewOffset(width, height, this.camera === this.pointCamera ? this.offsetX : 0, 0, width, height);
                this.worldCamera.updateProjectionMatrix();

                // Map camera
                this.mapCamera.aspect = width / height;
                this.mapCamera.updateProjectionMatrix();

                // Point of interest camera
                this.pointCamera.aspect = width / height;
                this.pointCamera.updateProjectionMatrix();
            };

            static update = () => {
                if (this.isTransitioning) {
                    return;
                }

                this.worldCamera.position.copy(this.camera.position);
                this.worldCamera.quaternion.copy(this.camera.quaternion);
            };
        }

        class WorldController {
            static init() {
                this.initWorld();
                this.initLights();
                this.initControls();

                this.addListeners();
            }

            static initWorld() {
                this.renderer = new WebGLRenderer({ antialias: true });

                // Output canvas
                this.element = this.renderer.domElement;

                // 3D scene
                this.scene = new Scene();
                this.scene.background = new Color(0x060606);

                // World camera
                this.camera = new PerspectiveCamera(35);
                this.camera.near = 1;
                this.camera.far = 2000;
                this.camera.position.z = 10;

                // Map camera
                this.mapCamera = this.camera.clone();

                // Point of interest camera
                this.pointCamera = this.camera.clone();
                this.pointCamera.position.z = 6;
            }

            static initLights() {
                this.scene.add(new HemisphereLight(0xffffff, 0x888888, 3));
            }

            static initControls() {
                // Map controls
                this.mapControls = new OrbitControls(this.mapCamera, this.renderer.domElement);
                this.mapControls.enableDamping = true;
                this.mapControls.enabled = false;

                // Point of interest controls
                this.poiControls = new OrbitControls(this.pointCamera, this.renderer.domElement);
                this.poiControls.enableDamping = true;
                this.poiControls.enablePan = false;
                this.poiControls.enabled = false;

                // Output camera controls
                this.controls = this.mapControls;
                this.controls.enabled = true;
            }

            static addListeners() {
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart);
            }

            // Event handlers

            static onTouchStart = e => {
                e.preventDefault();
            };

            // Public methods

            static setControls = controls => {
                this.controls = controls;

                this.mapControls.enabled = false;
                this.poiControls.enabled = false;

                this.controls.enabled = true;
            };

            static resize = (width, height, dpr) => {
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(width, height);
            };

            static update = () => {
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            };
        }

        class App {
            static async init() {
                this.initWorld();
                this.initViews();
                this.initControllers();

                this.addListeners();
                this.onResize();
            }

            static initWorld() {
                WorldController.init();
                document.body.appendChild(WorldController.element);
            }

            static initViews() {
                this.view = new SceneView();
                WorldController.scene.add(this.view);

                this.trackers = new TrackersView();
                document.body.appendChild(this.trackers.element);
            }

            static initControllers() {
                const { camera, mapCamera, pointCamera } = WorldController;

                CameraController.init(camera, mapCamera, pointCamera);
                SceneController.init(this.view);
                ServerStatusController.init(this.view, this.trackers);
            }

            static addListeners() {
                Stage.events.on('start', this.onStart);
            }

            // Event handlers

            static onStart = () => {
                Stage.events.on('details', this.onDetails);
                window.addEventListener('resize', this.onResize);
                ticker.add(this.onUpdate);
                ticker.start();
            };

            static onDetails = ({ open }) => {
                let camera;
                let controls;

                if (open) {
                    camera = WorldController.pointCamera;
                    controls = WorldController.poiControls;
                } else {
                    camera = WorldController.mapCamera;
                    controls = WorldController.mapControls;
                }

                CameraController.setCamera(camera);
                WorldController.setControls(controls);
            };

            static onResize = () => {
                const width = document.documentElement.clientWidth;
                const height = document.documentElement.clientHeight;
                const dpr = window.devicePixelRatio;

                WorldController.resize(width, height, dpr);
                CameraController.resize(width, height);
                ServerStatusController.resize(width, height, dpr);
            };

            static onUpdate = (time, delta, frame) => {
                WorldController.update(time, delta, frame);
                CameraController.update();
                SceneController.update(time);
                PanelController.update(time);
                ServerStatusController.update(time);
            };
        }

        App.init();
    </script>
</head>
<body>
</body>
</html>
